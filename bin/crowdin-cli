#!/usr/bin/env ruby

require 'pp'
require 'crowdin-cli'

# GLI_DEBUG=true bundle exec bin/crowdin-cli

# Setup i18n
# tell the I18n library where to find your translations
I18n.load_path += Dir[Pathname(__FILE__).dirname.expand_path + '../locales/*.yml']
I18n.locale = :en

# Return +hierarchy+ of directories and files in Crowdin project
#
# +files+ - basically, it's project files details from API method `project_info`
#
def get_remote_files_hierarchy(files, root = '/', hierarchy = { dirs: [], files: [] })
  files.each do |node|
    case node['node_type']
    when 'directory'
      hierarchy[:dirs] << "#{root}#{node['name']}"
      get_remote_files_hierarchy(node['files'], root + node['name'] + '/', hierarchy)
    when 'file'
      hierarchy[:files] << "#{root}#{node['name']}"
    end
  end

  return hierarchy
end

# Return +hierarchy+ of local directories and files
#
# @params [Array] files a list of files in a local directory.
#
def get_local_files_hierarchy(files, hierarchy = { dirs: [], files: [] })
  hierarchy[:files] = files

  dirs = files.inject([]) do |res, a|
    res << a.split('/').drop(1).inject([]) do |res, s|
      res << res.last.to_s + '/' + s
    end
  end
  dirs.map(&:pop) # delete last element from each array
  hierarchy[:dirs] = dirs.flatten.uniq

  return hierarchy
end

# @param [String] path relative path to file in Crowdin project
# @param [String] export_pattern basically, is a file['translation'] from crowdin.yaml
# @param [Hash] lang language information
# @option lang [String] :name
# @option lang [String] :crowdin_code
# @option lang [String] :iso_639_1
# @option lang [String] :iso_639_3
# @option lang [String] :locale
#
def export_pattern_to_path(path, export_pattern, lang, languages_mapping = nil)
  original_path      = File.dirname(path)
  original_file_name = File.basename(path)
  file_extension     = File.extname(path)[1..-1]
  file_name          = File.basename(path, File.extname(path))

  pattern = {
    '%language%'               => lang['name'],
    '%two_letters_code%'       => lang['iso_639_1'],
    '%three_letters_code%'     => lang['iso_639_3'],
    '%locale%'                 => lang['locale'],
    '%locale_with_underscore%' => lang['locale'].gsub('-', '_'),
    '%android_code%'           => android_locale_code(lang['locale']),
    '%original_file_name%'     => original_file_name,
    '%original_path%'          => original_path,
    '%file_extension%'         => file_extension,
    '%file_name%'              => file_name,
  }

  placeholders = pattern.inject([]){ |memo, h| memo << h.first[/%(.*)%/, 1] }

  unless languages_mapping.nil?
    pattern = Hash[pattern.map{ |placeholder, str| [
      placeholder,
      (languages_mapping[placeholder[/%(.*)%/, 1]][lang['crowdin_code']] rescue nil) || str]
    }]
  end

  export_pattern.gsub(/%(#{placeholders.join('|')})%/, pattern)
end

# @param [String] path relative path to file in Crowdin project
# @param [String] source basically, is a file['source'] from crowdin.yaml
# @param [String] translation basically, is a file['translation'] from crowdin.yaml
#
def construct_export_pattern(path, source, translation)
  pattern_regexp = translate_pattern_to_regexp(source)
  if pattern_regexp.names.include?('double_asterisk') and path.match(pattern_regexp)
    double_asterisk = path.match(pattern_regexp)['double_asterisk']
    translation = translation.sub('**', double_asterisk)
  end

  export_pattern = translation.split('/').reject(&:empty?).join('/').insert(0, '/')

  return export_pattern
end

# Provides a partial implementation of translate a glob +pattern+ to a regular expression
# NOTE:
# `**` surrounded by backslashes `/` in the +pattern+
# `**` used only once in the +pattern+
#
def translate_pattern_to_regexp(pattern)
  i = 0
  n = pattern.size
  res = ''
  while i < n
    c = pattern[i]
    i = i + 1
    if c == '*'
      j = i
      if j < n and pattern[j] == '*'
        res[-1] = '(\/)?(?<double_asterisk>.*)?'
        i = j + 1
      else
        res << '(.*)'
      end
    elsif c == '?'
      res << '.'
    else
      res << Regexp.escape(c)
    end
  end

  return Regexp.new(res)
end

def android_locale_code(locale_code)
  locale_code = case locale_code
    when 'he-IL' then 'iw-IL'
    when 'yi-DE' then 'ji-DE'
    when 'id-ID' then 'in-ID'
    else locale_code
  end
  return locale_code.sub('-', '-r')
end

def get_invalid_placeholders(export_pattern)
  valid_placeholders = [
    '%language%',
    '%two_letters_code%',
    '%three_letters_code%',
    '%locale%',
    '%locale_with_underscore%',
    '%android_code%',
    '%original_file_name%',
    '%original_path%',
    '%file_extension%',
    '%file_name%',
  ]

  all_placeholders = export_pattern.scan(/%[a-z0-9_]*?%/)
  invalid_placeholders = all_placeholders - valid_placeholders
end

# Return a string representing that part of the directory tree that is common to all the files
#
# @params [Array] paths set of strings representing directory paths
#
def find_common_directory_path(paths)
  return paths.first.split('/').slice(0...-1).join('/') if paths.length <= 1
  arr = paths.sort
  first = arr.first.split('/')
  last = arr.last.split('/')
  i = 0
  i += 1 while first[i] == last[i] && i <= first.length
  first.slice(0, i).join('/')
end

def unzip_file(zip, dest, files_list)
  # overwrite files if they already exist inside of the extracted path
  Zip.options[:on_exists_proc] = true

  unmatched_files = []

  Zip::ZipFile.open(zip) do |zip_file|
    zip_file.select{ |f| f.file? }.each do |f|
      file = files_list['/' + f.name]
      if file
        f_path = File.join(dest, file)
        FileUtils.mkdir_p(File.dirname(f_path))
        puts "Download: `#{file}'"
        zip_file.extract(f, f_path)
      else
        unmatched_files << f
      end
    end
  end

  unless unmatched_files.empty?
    puts "Warning: Downloaded translations does not match current project configuration. Some of the resulted files will be omitted."
    unmatched_files.each{ |file| puts " - `#{file}'" }
    puts "Crowdin has internal caching mechanisms that prevents us from overload. Please try to download translations later."
  end
end

###
include GLI::App

version Crowdin::CLI::VERSION

subcommand_option_handling :normal

program_desc I18n.t('app.desc')
program_long_desc I18n.t('app.long_desc')
sort_help :manually # help commands are ordered in the order declared
wrap_help_text :to_terminal

desc I18n.t('app.switches.verbose.desc')
switch [:verbose, :v], :negatable => false

desc I18n.t('app.flags.config.desc')
default_value File.join(Dir.pwd, 'crowdin.yaml')
arg_name '<s>'
flag [:config,:c]

desc I18n.t('app.commands.upload.desc')
long_desc I18n.t('app.commands.upload.long_desc')
command :upload do |c|

  c.desc I18n.t('app.commands.upload.commands.sources.desc')
  c.long_desc I18n.t('app.commands.upload.commands.sources.long_desc')
  c.command :sources do |c|

    c.desc I18n.t('app.commands.upload.commands.sources.switches.auto_update.desc')
    c.switch ['auto-update']

    c.action do |global_options, options, args|
      project_info = @crowdin.project_info

      source_language = project_info['details']['source_language']['code']

      # Crowdin supported languages list
      supported_languages = @crowdin.supported_languages
      source_language = supported_languages.find{ |lang| lang['crowdin_code'] == source_language }

      remote_project_tree = get_remote_files_hierarchy(project_info['files'])

      local_files = []
      dest_files = []

      @config['files'].each do |file|
        get_invalid_placeholders(file['translation']).each do |placeholder|
          puts "Warning: #{placeholder} is not valid variable supported by Crowdin. See http://crowdin.net/page/cli-tool#configuration-file for more details."
        end

        if File.exist?("#{@base_path}#{file['source']}")
          dest = file['source']
          dest_files << dest

          local_file = { dest: dest, source: "#{@base_path}#{file['source']}", export_pattern: file['translation'] }
          # Used only when uploading CSV file to define data columns mapping.
          local_file.merge!({ sheme: file['scheme'] }) if file.has_key?('scheme')
          local_file.merge!({ first_line_contains_header: file['first_line_contains_header'] }) if file.has_key?('first_line_contains_header')

          local_files << local_file
        else
          Dir.glob("#{@base_path}#{file['source']}").select{ |fn| File.file?(fn) }.each do |source|
            dest = source.sub("#{@base_path}", '') # relative path in Crowdin
            dest_files << dest

            export_pattern = construct_export_pattern(dest, file['source'], file['translation'])

            local_file = { dest: dest, source: source, export_pattern: export_pattern }
            local_file.merge!({ sheme: file['scheme'] }) if file.has_key?('scheme')
            local_file.merge!({ first_line_contains_header: file['first_line_contains_header'] }) if file.has_key?('first_line_contains_header')

            local_files << local_file
          end
        end # if
      end # @config['files']

      if dest_files.empty?
        exit_now! <<EOS
No source files to upload.
Check your configuration file to ensure that they contain valid directives.
See http://crowdin.net/page/cli-tool#configuration-file for more details.
EOS
      end

      common_dir = @preserve_hierarchy ? '' : find_common_directory_path(dest_files)

      local_project_tree = get_local_files_hierarchy(local_files.collect{ |h| h[:dest].sub(common_dir, '') })

      local_files.each{ |file| file[:dest].sub!(common_dir, '') }

      # Create directory tree
      #
      create_dirs = local_project_tree[:dirs] - remote_project_tree[:dirs]
      create_dirs.each do |dir|
        puts "Create directory `#{dir}`"
        @crowdin.add_directory(dir)
      end

      if options['auto-update'].nil? or options['auto-update']
        # Update existing files in Crowdin project
        #
        # array containing elements common to the two arrays
        update_files = local_project_tree[:files] & remote_project_tree[:files]
        files_for_upload = local_files.select{ |file| update_files.include?(file[:dest]) }
        files_for_upload.each do |file|
          print "Updating source file `#{file[:dest]}'"

          params = {}
          params[:scheme] = file.delete(:sheme)
          params[:first_line_contains_header] = file.delete(:first_line_contains_header)

          resp = @crowdin.update_file([] << file, params)
          case resp['files'].first[1]
          when 'skipped'
            puts "\rUpdating source file `#{file[:dest]}' - Skipped"
          when 'updated'
            puts "\rUpdating source file `#{file[:dest]}' - OK"
          end
        end
      end

      # Add new files to Crowdin project
      #
      add_files = local_project_tree[:files] - remote_project_tree[:files]
      files_for_add = local_files.select{ |file| add_files.include?(file[:dest]) }
      files_for_add.each do |file|
        print "Uploading source file `#{file[:dest]}'"

        params = {}
        params[:scheme] = file.delete(:sheme)
        params[:first_line_contains_header] = file.delete(:first_line_contains_header)

        resp = @crowdin.add_file([] << file, params)
        puts "\rUploading source file `#{file[:dest]}' - OK"
      end

    end # action
  end # command

  c.desc I18n.t('app.commands.upload.commands.translations.desc')
  c.long_desc I18n.t('app.commands.upload.commands.translations.long_desc')
  c.command :translations do |c|

    c.desc I18n.t('app.commands.upload.commands.translations.flags.language.desc')
    c.default_value 'all'
    c.arg_name 'crowdin_language_code'
    c.flag [:language, :l]

    c.desc I18n.t('app.commands.upload.commands.translations.switches.import_duplicates.desc')
    c.switch ['import-duplicates']

    c.desc I18n.t('app.commands.upload.commands.translations.switches.import_eq_suggestions.desc')
    c.switch ['import-eq-suggestions']

    c.desc I18n.t('app.commands.upload.commands.translations.switches.auto_approve_imported.desc')
    c.switch ['auto-approve-imported']

    c.action do |global_options, options, args|
      params = {}
      params[:import_duplicates]     = options['import-dublicates']     ? 1 : 0
      params[:import_eq_suggestions] = options['import-eq-suggestions'] ? 1 : 0
      params[:auto_approve_imported] = options['auto-approve-imported'] ? 1 : 0

      language = options[:language]

      project_info = @crowdin.project_info

      remote_project_tree = get_remote_files_hierarchy(project_info['files'])

      project_languages = project_info['languages'].collect{ |h| h['code'] }
      if language != 'all'
        if project_languages.include?(language)
          project_languages = [] << language
        else
          exit_now!("language '#{language}' doesn't exist in a project")
        end
      end

      supported_languages = @crowdin.supported_languages
      translation_languages = supported_languages.select{ |lang| project_languages.include?(lang['crowdin_code']) }

      source_language = project_info['details']['source_language']['code']
      source_language = supported_languages.find{ |lang| lang['crowdin_code'] == source_language }

      translated_files = Hash.new{ |hash, key| hash[key] = Array.new }
      dest_files = []

      @config['files'].each do |file|
        get_invalid_placeholders(file['translation']).each do |placeholder|
          puts "Warning: #{placeholder} is not valid variable supported by Crowdin. See http://crowdin.net/page/cli-tool#configuration-file for more details."
        end

        languages_mapping = file['languages_mapping']

        if File.exists?("#{@base_path}#{file['source']}")
          dest = file['source'].sub("#{@base_path}", '')
          dest_files << dest

          translation_languages.each do |lang|
            source = export_pattern_to_path(dest, file['translation'], lang, languages_mapping)
            translated_files[lang['crowdin_code']] << { source: "#{@base_path}#{source}", dest: dest }
          end
        else
          Dir.glob("#{@base_path}#{file['source']}").select{ |fn| File.file?(fn) }.each do |source|
            dest = source.sub("#{@base_path}", '') # relative path in Crowdin
            dest_files << dest

            export_pattern = construct_export_pattern(dest, file['source'], file['translation'])

            translation_languages.each do |lang|
              source = export_pattern_to_path(dest, export_pattern, lang, languages_mapping)
              translated_files[lang['crowdin_code']] << { source: "#{@base_path}#{source}", dest: dest }
            end

          end
        end # if
      end # @config['files']

      if dest_files.empty?
        exit_now! <<EOS
No translation files to upload.
Check your configuration file to ensure that they contain valid directives.
See http://crowdin.net/page/cli-tool#configuration-file for more details.
EOS
      end

      common_dir = @preserve_hierarchy ? '' : find_common_directory_path(dest_files)

      translated_files.each_pair do |language, files|
        files.each do |file|
          file[:dest] = file[:dest].sub(common_dir, '')

          if remote_project_tree[:files].include?(file[:dest])
            if File.exist?(file[:source])
              print "Uploading translation file `#{file[:source].sub(@base_path, '')}'"

              resp = @crowdin.upload_translation([] << file, language, params)
              case resp['files'].first[1]
              when 'skipped'
                puts "\rUploading translation file `#{file[:source].sub(@base_path, '')}' - Skipped"
              when 'uploaded'
                puts "\rUploading translation file `#{file[:source].sub(@base_path, '')}' - OK"
              end
            else
              puts "Warning: Local file `#{file[:source]}' does not exists"
            end
          else
            # if source file not exist, don't upload translation
            puts "Warning: Skip `#{file[:source].sub(@base_path, '')}'"
          end
        end
      end

    end # action
  end # command

end

desc I18n.t('app.commands.download.desc')
#arg_name 'Describe arguments to download here'
command :download do |c|

  c.desc I18n.t('app.commands.download.flags.language.desc')
  c.arg_name 'language_code'
  c.flag [:language, :l], :default_value => 'all'

  c.action do |global_options ,options, args|
    language = options[:language]

    project_info = @crowdin.project_info

    remote_project_tree = get_remote_files_hierarchy(project_info['files'])

    project_languages = project_info['languages'].collect{ |h| h['code'] }
    if language != 'all'
      if project_languages.include?(language)
        project_languages = [] << language
      else
        exit_now!("language '#{language}' doesn't exist in a project")
      end
    end

    # use export API method before to download the most recent translations
    @crowdin.export_translations

    supported_languages = @crowdin.supported_languages
    translation_languages = supported_languages.select{ |lang| project_languages.include?(lang['crowdin_code']) }

    source_language = project_info['details']['source_language']['code']
    source_language = supported_languages.find{ |lang| lang['crowdin_code'] == source_language }

    # keys is all possible files in zip archive
    # values is resulted local files
    # usually they are equal
    downloadable_files = {}

    @config['files'].each do |file|
      languages_mapping = file['languages_mapping'] #Hash or NilClass

      if File.exists?("#{@base_path}#{file['source']}")
        dest = file['source'].sub("#{@base_path}", '')

        translation_languages.each do |lang|
          zipped_file = export_pattern_to_path(dest, file['translation'], lang)
          local_file  = export_pattern_to_path(dest, file['translation'], lang, languages_mapping)

          downloadable_files[zipped_file] = local_file
        end
      else
        Dir.glob("#{@base_path}#{file['source']}").select{ |fn| File.file?(fn) }.each do |source|
          dest = source.sub("#{@base_path}", '') # relative path in Crowdin

          export_pattern = construct_export_pattern(dest, file['source'], file['translation'])

          translation_languages.each do |lang|
            zipped_file = export_pattern_to_path(dest, export_pattern, lang)
            local_file  = export_pattern_to_path(dest, export_pattern, lang, languages_mapping)

            downloadable_files[zipped_file] = local_file
          end

        end
      end # if
    end # @config['files']

    ##
    file = Tempfile.new(language)
    path = file.path
    begin
      @crowdin.download_translation(language, output: path)
      unzip_file(path, @base_path, downloadable_files)
    ensure
      file.close
      file.unlink # delete the temp file
    end
  end

end

pre do |globals ,command, options, args|
  # Pre logic here
  # Return true to proceed; false to abourt and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only

  if File.exists?(globals[:config])
    @config = YAML.load_file(globals[:config])

    ['api_key', 'project_identifier'].each do |key|
      unless @config[key]
        exit_now! <<EOS
Configuration file misses required option `#{key}`

See http://crowdin.net/page/cli-tool#configuration-file for more details
EOS
      end
    end

    unless @config['files']
      exit_now! <<EOS
Configuration file misses required section `files`

See http://crowdin.net/page/cli-tool#configuration-file for more details
EOS
    end

  else
    exit_now! <<EOS
Can't find configuration file (default `crowdin.yaml').
Type `crowdin-cli help` to know how to specify custom configuration file

See http://crowdin.net/page/cli-tool#configuration-file for more details
EOS
  end

  @config['files'].each do |file|
    file['source'] = '/' + file['source'] unless file['source'].start_with?('/')
    file['translation'] = '/' + file['translation'] unless file['translation'].start_with?('/')

    if file['source'].include?('**')
      if file['source'].scan('**').size > 1
        exit_now! <<EOS
Source pattern `#{file['source']}` is not valid. The mask `**` can be used only once in the source pattern.
EOS
      elsif file['source'].scan('**').size == 1 and !file['source'].match(/\/\*\*\//)
        exit_now! <<EOS
Source pattern `#{file['source']}` is not valid. The mask `**` must be surrounded by backslashes `/` in the source pattern.
EOS
      end
    else
      if file['translation'].include?('**')
        exit_now! <<EOS
Translation pattern `#{file['translation']}` is not valid. The mask `**` can't be used.
When using `**` in 'translation' pattern it will always contain sub-path from 'source' for certain file.
EOS
      end
    end

  end # @config['files']

  if @config['base_path']
    @base_path = @config['base_path']
  else
    @base_path = Dir.pwd
    puts <<EOS
Warning: Configuration file misses parameter `base_path` that defines your project root directory. Using `#{@base_path}` as a root directory.
EOS
  end

  if @config['remote_path']
    @remote_path = @config['remote_path']
    @remote_path = '/' + @remote_path unless @remote_path.start_with?('/')
  else
    @remote_path = ''
  end

  @preserve_hierarchy = false
  if @config['preserve_hierarchy']
    @preserve_hierarchy = case @config['preserve_hierarchy']
      when true
        true
      when false
        false
      else
        exit_now! <<EOS
Parameter `preserve_hierarchy` allows values of true or false.
EOS
    end
  end

  Crowdin::API.log = Logger.new($stderr) if globals[:verbose]
  @crowdin = Crowdin::API.new(api_key: @config['api_key'], project_id: @config['project_identifier'], base_url: @config['base_url'] || 'http://api.crowdin.net')
  begin
    @crowdin.project_info
  rescue Crowdin::API::Errors::Error => err
    raise err
  rescue
    exit_now!("Seems Crowdin server API URL is not valid. Please check the `base_url` parameter in the configuration file.")
  end

  #puts "Executing #{command.name}" if globals[:verbose]
  true
end

post do |globals, command, options, args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
  #puts "Executed #{command.name}" if globals[:verbose]
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
